---
title: "Extended results for: The balance of nature: Critical Role of Species Intrinsic Responses for Stability"
author: "Til H√§mmig, Francesco Polazzo, Owen L. Petchey, Frank Pennekamp"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: hide
    keep_md: yes
    fig_caption: true  
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
rm(list=ls())
library("ggplot2")
library("tidyverse")
library("gridExtra")
#library(rEDM)
library("parallel")
library("pracma")
library("purrr")
library("signal")
library("ggfortify")
library("data.table")
library("patchwork")
library("codyn")
library("ggrepel")
library("lme4")
library("lmerTest")
library("MuMIn")
library("RColorBrewer")
library("broom")
library("relaimpo")
library("lavaanPlot")
library(ggbeeswarm)
library(performance)
library(broom)
library(kableExtra)
library(gt)
library(lavaan)
#devtools::install_github("canankarakoc/r_package_EDMhelper/EDMhelper")

```

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      include = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE)
```


# Introduction

The purpose of this document is to provide a reproducible record of all analyses and figures in the main article. The main article is focused on the effect of species' intrinsic responses on community stability in fluctuating environments. We are going to look at the effect of the distribution of species responses, richness, temperature and nutrients on community temporal stability. Specifically, we are going to look at the effect of fundamental imbalance (our measurement of the distribution of species' intrinsic responses) on temporal stability. Species' intrinsic responses to environmental change can stabilise community biomass in two ways: through response diversity and /or through population stability. Thus, as response diversity is thought to stabilize temporal stability of aggregate community properties via asynchrony, we are going to look at the relationship between response diversity and asynchrony. Subsequently, we are going to look at the relationship between population stability and temporal stability of community biomass.
Finally, we use a structural equation model to test the direct and indirect effects of balance on temporal stability of community biomass.

In this document, we also analyse the predictive power of imbalance and divergence on temporal stability, and we compare the unique explanatory power of imbalance and divergence. We also look at the interaction between divergence and richness, and between imbalance and richness. Finally, we assess variable importance using the relative importance of predictors in the full model. This part of the document (section 5), is not included in the main article, but it is an important part of the analysis that justify adopting imbalance instead of divergence, which was the original metric used to design the experiment.

This document is produced by an Rmarkdown file that includes code to reproduce from data all results presented in the main article.



# Load datasets, Data wrangling and balance calculation

```{r  warning=FALSE, results='hide'}

divergence_df <- read_csv("Data/divergence_df.csv")
load("Data/dens_biomass_poly.RData")

dd_all_pred<-read.csv("Data/morph_dd_pred.csv")
dd_all_pred_nonoise<-read.csv("Data/morph_dd_pred_nonoise.csv")

load("Data/ciliate_traits.Rdata")

df_slopes <- read_csv("Data/df_slopes_cor.csv")

# needs to have id_new variable
ciliate_traits <- ciliate_traits %>%
  dplyr::mutate(
    # Remove dots from the date
    cleaned_date = gsub("\\.", "", date),
    # Extract the part of id after the underscore
    id_suffix = sub(".*_(.*)", "\\1", id),
    # Combine cleaned_date, id_suffix, and species_initial into a new variable
    id_new = paste0(cleaned_date, id_suffix, composition)
  ) %>%
  # Optionally, remove the intermediate columns to clean up
  dplyr::select(-cleaned_date, -id_suffix,-new_id)

uniqueN(ciliate_traits$id_new)==nrow(ciliate_traits) # all unique  ;)

id_dd<-full_join(dd_all_pred,dplyr::select(ciliate_traits,id_new,biomass),join_by("id_new"))


## add day variable

#create a day variable from the date variable

id_dd<-dplyr::mutate(id_dd,date=as.Date(date,format = "%d.%m.%y"))

earliest_date<-min(id_dd$date)
days_since_earliest<-as.numeric(id_dd$date-earliest_date)+1
id_dd<-id_dd%>%dplyr::mutate(day=days_since_earliest)

#create a summarised df on microcosm level with each species seperate
# Make sure, that we have n_frames and not N_frames
names(id_dd)[names(id_dd) == "N_frames"] <- "n_frames"

#extrapolation_factor <- 9.301902  # for 16 x magnification 
extrapolation_factor <- 9.828125  # for 25 x magnification 
video_biomass_species <- c( "C", "P", "S","D","L","T")

biomasses <- id_dd %>%
  dplyr::group_by( day,temperature,nutrients,sample_ID,composition,predict_spec) %>% # group  by xxx
  dplyr::summarize(
    biomass = sum(biomass * n_frames, na.rm = TRUE) / (1 * 125) # if not 3 videos corrections is done below with dens_factor
  ) %>%
  dplyr::mutate(
    biomass = biomass * extrapolation_factor,
    )

biomasses<-biomasses%>%dplyr::mutate(biomass=biomass*1000)

dd_ts_id<-biomasses

#fill up missing dates with biomass<-0

fill_dd<-expand.grid(sample_ID=unique(dd_ts_id$sample_ID),day=unique(dd_ts_id$day),predict_spec=unique(dd_ts_id$predict_spec))
complete_ts<-full_join(fill_dd,dd_ts_id,join_by(sample_ID,day,predict_spec))

complete_ts$biomass[is.na(complete_ts$biomass)]<-0
complete_ts<-complete_ts%>%dplyr::mutate(composition=sub("_.*", "", sample_ID))
complete_ts<-complete_ts %>%
  dplyr::mutate(temperature = sapply(strsplit(as.character(sample_ID), "_"), function(x) paste(x[3], x[4], sep = "-")))
complete_ts<- dplyr::mutate(complete_ts,nutrients = gsub(".*Nut(.*?)_.*", "\\1", sample_ID))

# Now remove wrong combinations of composition and predict_spec / predict_spec

complete_ts<- complete_ts %>%
  rowwise() %>%
  dplyr::filter(predict_spec %in% unlist(strsplit(composition, ""))) %>%
  ungroup()  
complete_ts<-dplyr::mutate(complete_ts,temperature=as.character(temperature),
                    nutrients=as.character(nutrients),
                    richness=nchar(composition))

complete_ts<-complete_ts%>%group_by(sample_ID,composition,day)%>%dplyr::mutate(tot_biomass=sum(biomass))
complete_ts<-complete_ts%>%dplyr::mutate(biom_contribution=biomass/tot_biomass)

df_biomass_mod <- complete_ts

complete_ts<-complete_ts%>%dplyr::mutate(temperature=paste0(temperature," ¬∞C"),
                                      nutrients=paste0(nutrients," g/L"))


# introduce slopes of 
names(df_slopes)[names(df_slopes)=="species_initial"]<-"predict_spec"

slope_ts<-full_join(dplyr::select(df_slopes,nutrients,predict_spec,temperature,slope),complete_ts)
slope_ts<-slope_ts%>%dplyr::mutate(w_slope=biom_contribution*slope,
                            sign=sign(slope))

slope_ts<-slope_ts%>%group_by(sample_ID,temperature,nutrients,richness,composition,day,tot_biomass)%>%dplyr::summarize(
  sum_w_slopes=abs(sum(w_slope)),
                   mean_abs_slope=mean(abs(slope)),
  sum_abs_slope=sum(abs(slope)),
  abs_sum_slope=abs(sum(slope)),
  symmetry=abs(sum(sign)))


slope_ts<-slope_ts%>%dplyr::mutate(richness=as.factor(richness))


##create new variable where it checks, where the last observation =0 is; with complete_ts
aggr_ts <- slope_ts %>%
  group_by( sample_ID) %>%
  arrange(day) %>%
  mutate(
    # Create a flag for non-zero tot_biomass
    non_zero_biomass = tot_biomass != 0,
    # Find the last non-zero day
    last_non_zero_day = ifelse(any(non_zero_biomass), max(day[non_zero_biomass], na.rm = TRUE), NA),
    # Find the first zero day after the last non-zero day
    first_zero_day = ifelse(
      !is.na(last_non_zero_day),
      min(day[!non_zero_biomass & day > last_non_zero_day], na.rm = TRUE),
      NA
    ),
    # Flag for days after the first zero day
    is_after_first_zero_day = ifelse(!is.na(first_zero_day), day > first_zero_day, FALSE)
  ) %>%
  ungroup()

aggr_ts<-aggr_ts%>%mutate(rep_var=sub("_[^_]+$", "", sample_ID))

biomass_ts<-aggr_ts%>%dplyr::group_by(day,temperature,nutrients,richness)%>%summarize(tot_biom=mean(tot_biomass),se_tot_biom=sd(tot_biomass)/sqrt(as.numeric(length(tot_biomass))))


```


# Biomass

Let's have a look at the biomass dynamics in the different environmental treatments.

### tot biomass plot

```{r plot_biomass, fig.align="center", fig.height=8, fig.width=15}

plot_biomass<-ggplot(data=biomass_ts)+
  geom_ribbon(aes(x=day,y=tot_biom,fill=richness,color=richness,ymin=tot_biom-se_tot_biom,ymax=tot_biom+se_tot_biom),show.legend=F,alpha=0.5)+
  geom_line(method="loess",se=F,aes(x=day,y=tot_biom,color=richness),size=0.8)+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
   scale_fill_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  theme_classic()+
  #geom_text_repel( data=biomass_ts%>%dplyr::filter(day==58,tot_biom!=0),aes(x=day,y=tot_biom,group=composition,label = composition), size = 4,max.overlaps = 20) +
  facet_wrap(temperature~nutrients,scale="free_y")+
  theme(axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 12))+
  ylab(expression("Community biomass [mg ml"^-1 * "]"))
  
plot_biomass
```

 **Figure 1** : Community total biomass during the experiment in different environmental treatments. Different color represent richness levels.



# Main Results 

We now look at the main results of the experiment. We are going to look first at the effect of richness, temperature and nutrients on community temporal stability. Then, we are going to look at the relationship between divergence (original response diversity metric) and temporal stability. Finally, we are going to look at the relationship between response diversity and temporal stability.

In the whole analysis, we calculated the temporal stability of total community biomass as the inverse of the coefficient of variation (ICV) (i.e. $\frac{\sigma}{\mu}$). 
```{r results='hide', echo=FALSE, warning=FALSE}
## discard all the rows that are part of time stretches where entire microcosms has (seemingly) gone extinct
#%>%dplyr::filter(is_after_first_zero_day==FALSE)

complete_aggr<-aggr_ts %>%group_by(composition,nutrients,temperature,sample_ID)%>%reframe(
  avg_w_sumslopes=mean(sum_w_slopes,na.rm = T),
  abs_sum_slope=mean(abs_sum_slope),
  magnitude=mean(mean_abs_slope),
  symmetry=mean(symmetry),
  sum_abs_slope=mean(sum_abs_slope),
  CV=sd(tot_biomass)/mean(tot_biomass),
  mean_biomass=mean(tot_biomass))

complete_aggr<-full_join(divergence_df,complete_aggr,by=join_by(composition,nutrients,temperature))%>%
  mutate(richness=as.factor(richness))



```

### Effect of T, N and R
```{r boxplots_TNR, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=8, fig.width=14}
#### effects of temperature; nutrient and richness, now with complete time series

plot_T_complete<-ggplot(data=complete_aggr)+
  geom_boxplot(aes(y=log10(1/CV),x=temperature))+
  geom_jitter(aes(y=log10(1/CV),x=temperature))

plot_T_complete<-ggplot(data=complete_aggr)+theme_bw(base_size = 25)+
  geom_quasirandom(data= complete_aggr,aes(y=log10(1/CV), x=temperature, group=temperature, colour=as.factor(temperature)),
                                  dodge.width=2, size=2.5) + 

  xlab("Temperature regime")+
  labs(color="Temperature regime", tag = "(b)")+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) 


plot_N_complete<-ggplot(data=complete_aggr)+
  geom_boxplot(aes(y=log10(1/CV),x=nutrients))+
  geom_jitter(aes(y=log10(1/CV),x=nutrients,color=richness))

plot_N_complete<-ggplot(data=complete_aggr)+ theme_bw(base_size = 25)+
  geom_quasirandom(data= complete_aggr,aes(y=log10(1/CV), x=nutrients, group=nutrients, colour=as.factor(nutrients)),
                                  dodge.width=2, size=2.5) + 

  xlab("Nutrients")+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) + labs(tag = "(c)")

plot_R_complete<-ggplot(data=complete_aggr)+
  geom_boxplot(aes(y=log10(1/CV),x=richness))+
  geom_jitter(aes(y=log10(1/CV),x=richness))

plot_R_complete<-ggplot(data=complete_aggr)+theme_bw(base_size = 25)+
  geom_quasirandom(data= complete_aggr,aes(y=log10(1/CV), x=richness, group=richness, colour=as.factor(richness)),
                                  dodge.width=2, size=4) + 

  
  
  xlab("Richness")+
  theme(legend.position = "none",
        axis.title.y = element_blank())+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) + labs (tag = "(a)") 

combined_plot<-plot_R_complete/
(plot_T_complete+
plot_N_complete)

combined_plot<- wrap_elements(combined_plot) +
  labs(tag = "Temporal stability\nlog(mean/s.d.)")+
  theme(
    plot.tag = element_text(size = rel(2.5), angle = 90),
    plot.tag.position = "left"
  )
combined_plot
# expression(atop("Temporal stability", log[10]("mean/s.d.")))
#ggsave("figures_ms/fig.1.png", plot = combined_plot, width = 14, height = 8, dpi = 600)


```
**Figure 2**: Effects of richness (a), temperature (b), and nutrients (c) on community total biomass temporal stability.



We can see that richness does not have a clear effect on community temporal stability, while stability was higher at lower temperature, and nutrients increased community temporal stability.

### Effect of Divergence

We look at the relationship between divergence (our original response diversity metric) and stability

```{r divergence_CV, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=16}

plot_CV_divergence<-complete_aggr%>%ggplot(aes(x=divergence,y=log10(1/CV),color=richness))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",aes(x=divergence,y=log10(1/CV),color=richness),show.legend=F, linewidth = 2)+theme_classic()+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) +
    theme(
    axis.title.x = element_text(size = 25),
    axis.title.y = element_text(size = 25),
    axis.text = element_text(size = 14),                      # Axis text size             # Facet label text size
    legend.title = element_text(size = 20),                   # Legend title size
    legend.text = element_text(size = 20),                     # Legend text size
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 22)) +
  facet_wrap(~richness, labeller = as_labeller(function(x) paste0("richness = ", x)))+
  ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("divergence") 


plot_CV_divergence

```


**Figure 3**: Relationship between Divergence and temporal stability of total community biomass.



Divergence is positively related to temporal stability, suggesting that response diversity promotes stability. However, the relationship between divergence and stability becomes weaker as richness increases. We think that this is due to divergence considering only the responses of the 2 most "responding" species. Thus, when species richness increases, disregarding the responses of the other species in the community except the 2 responding the most makes the relationship between response diversity and stability weaker. 

This is why, after running the experiment, we developed another metric to measure the distribution of species' responses, which we called **imbalance**, and that is presented in the main text of the publication. 
Imbalance has several desirable features that makes it a more suitable metric than divergence: Independence of richness, higher predictive power, and accounts for the responses of all species in the community (as opposed to divergence that accounts for only the 2 most "responding" species).

Here, we provide extensive evidence of why imbalance is a better metric to measure response diversity than divergence, and thus justifying focusing the analysis around imbalance.

# Comparing Divergence and Imbalance

## Predictive power of Divergence and Imbalance

We first compare how well divergence and imbalance predict stability (predictive power). 

```{r results='hide', echo=FALSE, warning=FALSE, message=FALSE}

complete_aggr <- complete_aggr %>% mutate(stability = 1/CV) %>% 
  dplyr::rename(balance_f = abs_sum_slope,
                balance_r = avg_w_sumslopes)



# summary(lm_full)
# anova(lm_full)
```

### Imbalance

```{r model_check1, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
# 

mod1 <- lm(data=complete_aggr,log10(stability)~log10(balance_f))

# Check model assumptions
#check_model(mod1)

```



### Divergence
```{r model_check2, include=TRUE, echo=TRUE, fig.align="center", fig.height=9, fig.width=12}
mod2 <- lm(data=complete_aggr,log10(stability)~(divergence))

# Check model assumptions
#check_model(mod2)

```



**Table 1**: Comparison of model performance of divergence and imbalance as predictors of stability. Model 1 has imbalance as predictor and model 2 has divergence as predictor.
```{r}
# compare performance tables of mod1 and mod2 specifying 
performance(mod1) %>% 
  bind_rows(performance(mod2), .id = "model") %>% 
  kable() %>% 
  kable_styling(full_width = F)
```

A model with imbalance as predictor performs better than one with divergence as predictor, and it explains more of the variance in stability than divergence.



Moreover, from **Figure 3**, it looks like divergence declines in performance as richness increases. Let's test this analytically.
To do than we build a linear model having stability as response variable and either log10(imbalance) or divergence as predictor for each richness level. We then extract the R squared of the models and their *standardised* estimates. (standardized estimates were calculated centering divergence and imbalance using the function scale()).

```{r include = TRUE, echo=TRUE}
# getting model estimates for each richness level
lm_divergence_richness_E <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(divergence), data = .x)),
    results = map(model, broom::tidy)
  ) %>%
  unnest(results) %>% dplyr::filter(term=="scale(divergence)") 


# getting model R squared for each richness level

lm_divergence_richness_R <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(divergence), data = .x)),
    results = map(model, broom::glance)
  ) %>%
  unnest(results) 

```


```{r include = TRUE, echo=TRUE}

# getting model estimatesf or each richness level
lm_balance_richness_E <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(log10(balance_f)), data = .x)),
    results = map(model, broom::tidy)
  ) %>%
  unnest(results) %>% dplyr::filter(term=="scale(log10(balance_f))") 



# getting model R squared for each richness level
lm_balance_richness_R <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(log10(balance_f)), data = .x)),
    results = map(model, broom::glance)
  ) %>%
  unnest(results) 

```


```{r R_squared, fig.align="center", fig.height=5, fig.width=15}
# plot how the r squared changes with richness for divergence and balance with legend and lines with diamond instead of points


a <- ggplot(data = lm_divergence_richness_R, aes(x = richness, y = r.squared, color = "Divergence")) +
  geom_point( shape = 18, cex = 5 )  +
  geom_point(data = lm_balance_richness_R, aes(x = richness, y = r.squared, color = "Imbalance"), shape = 18, cex = 5 ) +
  labs(x = "Richness", y = "R squared", color = "Model") +
theme_minimal(base_size = 20) +
  scale_color_manual(values = c("Divergence" = "blue", "Imbalance" = "red"))+ labs(tag = "(a)")


# plot how the estinmates changes with richness for divergence and balance with legend and lines
b <- ggplot(data = lm_divergence_richness_E, aes(x = richness, y = estimate, color = "Divergence") ) +
  geom_point(shape = 18, cex = 5) +
  geom_point(data = lm_balance_richness_E, aes(x = richness, y = abs(estimate), color = "Imbalance"), shape = 18, cex = 5 ) +
  labs(x = "Richness", y = "Estimate", color = "Model") +
  theme_minimal(base_size = 20) +
  scale_color_manual(values = c("Divergence" = "blue", "Imbalance" = "red")) + labs(tag = "(b)")

a + b

```
**Figure 4**: Performance comparison of divergence vs imbalance. In (a), the R squared of linear models for divergence and imbalance are shown for each richness level. In (b), the estimates of the linear models for divergence and imbalance are shown for each richness level.




We can see that the R squared of divergence as predictor of stability becomes smaller as richness increases, while the R squared of imbalance as predictor of stability does not (actually increases slightly). 


## Comparing unique explanatory power of imbalance and divergence

Now we build a linear model were stability is modeled as a function of imbalance and divergence. 
Then, we compared the variance explained by the full model compared to a model containing either only imbalance or only divergence.


### Full model - imbalance and divergence

```{r model_check3, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_div_balance <- lm(data=complete_aggr,log10(stability)~log10(balance_f)+divergence)

# Check model assumptions
# check_model(lm_div_balance)
```



### model with only divergence
```{r model_check4, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_div <- lm(data=complete_aggr,log10(stability)~divergence)

# Check model assumptions
# check_model(lm_div)
```




### model with only imbalance
```{r model_check5, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_balance <- lm(data=complete_aggr,log10(stability)~log10(balance_f))

# Check model assumptions
# check_model(lm_balance)
```


### Comparision full model vs divergence only and imbalance only


**Table 2**: Comparison of model performance of divergence, imbalance and both as predictors of stability. Model 1 has both imbalance and divergence as predictors, model 2 has divergence as predictor, and model 3 has imbalance as predictor.
```{r}
# compare performace tables of lm_div_balance, lm_div and lm_balance
performance(lm_div_balance) %>% 
  bind_rows(performance(lm_div), .id = "model") %>% 
  bind_rows(., performance(lm_balance), .id = "model") %>% 
  kable() %>% 
  kable_styling(full_width = F)

```



### Comparision full model vs imbalance only

**Table 3**: Anova table: a model with both imbalance and divergence as predictors is not significantly different from a model with only imbalance as predictor.
```{r include = TRUE, echo=TRUE}
anova1 <- anova(lm_div_balance,  lm_balance)

# Convert to tidy format
anova_tidy1 <- broom::tidy(anova1)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy1 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )


```


### Comparision full model vs imbalance only and divergence only

**Table 4**: Anova table: a model with both imbalance and divergence as predictors is significantly better from a model with only divergence as predictor.
```{r include = TRUE, echo=TRUE}
anova2 <- anova(lm_div_balance,  lm_div)


anova_tidy2 <- broom::tidy(anova2)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy2 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```

Overall, imbalance explains more of the variance in stability than divergence, and there is virtually no difference between a model containing only imbalance and the full model.




## Interaction divergence and richness

Richness had to be transformed to numeric and to be centered to avoid collinearity with divergence

```{r model_check6, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}


lm_rich_div <- lm(data=complete_aggr,log10(stability)~divergence*scale(as.numeric(richness)))

# check model assumptions
# check_model(lm_rich_div)
```




**Table 5**: Type III anova table of the model with divergence and richness as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova3 <- car::Anova(lm_rich_div, type = "III")

anova_tidy3 <- broom::tidy(anova3)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy3 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```


Divergence significantly interact with richness, suggesting that the relationship between divergence and stability changes with richness. 
While an ideal metric of response diversity should be independent of richness.



We repeat the same model using imbalance instead of divergence.
```{r model_check7, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_rich_balance <- lm(data=complete_aggr,log10(stability)~log10(balance_f)*scale(as.numeric(richness)))

# check model assumptions
# check_model(lm_rich_balance)
```





**Table 6**: Type III anova table of the model with imbalance and richness as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova4 <- car::Anova(lm_rich_balance, type = "III")

anova_tidy4 <- broom::tidy(anova4)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy4 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```

Imbalance does not significantly interact with richness, suggesting that the relationship between imbalance and stability is stable across richness levels.


## Variable importance

Finally, we assess variable importance using the relative importance of predictors in the full model.
We use the package vip (https://cran.r-project.org/web/packages/vip/vignettes/vip.html) to calculate the relative importance of predictors in the full model.
The function vip::vip for multiple linear regression, or linear models (LMs), uses the absolute value of the -statistic  as a measure of VI.
Motivation for the use of the associated ùë°-statistic is given in Bring (1994) [https://www.tandfonline.com/doi/abs/10.1080/00031305.1994.10476059].

```{r vip1, fig.align="center", fig.height=4, fig.width=8, include=TRUE, echo=TRUE}
vip::vip(lm_div_balance)
```
**Figure 5**: Variable importance in the model including both imbalance and divergence as predictors of stability.


We believe that the extensive evidence here provided justifies focusing the analysis around imbalance, and not divergence, as a metric of response diversity.
We will thus only look at imbalance for the rest of the analysis. 

# Effect RD

We are now going to look at how imbalance affected temporal stability of total community biomass. We are going to look at the relationship between fundamental imbalance (so based only on species response surfaces measured in monoculture), an realised imbalance (measured accounting for species contribution to balance).

This is fundamentally testing our most important hypothesis.

```{r effect_RD, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=20}

balance_dd<-complete_aggr%>%dplyr::select(balance_f,richness,CV)%>%
  cbind(type="fundamental")%>%mutate(balance_f=balance_f/as.numeric(richness))
names(balance_dd)[names(balance_dd)=="balance_f"]<-"balance"

weighted_balance_dd<-complete_aggr%>%dplyr::select(balance_r,richness,CV)%>%
  cbind(type="realised")
names(weighted_balance_dd)[names(weighted_balance_dd)=="balance_r"]<-"balance"

main_r_dd<-rbind(balance_dd,weighted_balance_dd)


plot_main <- main_r_dd %>%
  ggplot(aes(x = (log10(balance)), y = log10(1/CV), color = type)) +
  geom_point(aes(x = log10(balance), y = log10(1/CV)), size = 5, alpha = 0.65) +
  geom_smooth(method = "lm", aes(x = log10(balance), y = log10(1/CV)), linewidth = 3, show.legend=F) +
  theme_classic() +
  scale_color_viridis_d(option = "inferno", begin = 0.3, end = 0.6) +
  ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("log10(Imbalance)") +
 theme(
    axis.title.x = element_text(size = 25),
    axis.title.y = element_text(size = 25),
    axis.text = element_text(size = 20),                      # Axis text size             # Facet label text size
    legend.title = element_text(size = 25),                   # Legend title size
    legend.text = element_text(size = 25),                     # Legend text size
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
  labs(color = "Imbalance") +  
  facet_wrap(~richness, labeller = as_labeller(function(x) paste0("richness = ", x)))

plot_main

#ggsave("figures_ms/fig.2.png", plot = plot_main, width = 20, height = 10, dpi = 600)
```
**Figure 6**: Effects of fundamental and realised imbalance on total community biomass temporal stability.


We can see that imbalance is always negatively related to temporal stability, which means that balance in species responses promotes stability across richness levels. Interestingly, we see that there is little difference between fundamental and realised imbalance. Yet, as the richness increases, the relationship between realised imbalance and stability becomes steeper compared to fundamental balance. 


But is the difference between fundamental and realised imbalance significant? We can test this using a linear model with both fundamental and realised imbalance as predictors of stability, and one with only fundamental imbalance as predictor of stability, and compare whether the models are significantly different.

## Imbalance: realised vs fundamental
```{r include=TRUE, echo=TRUE}
# compare if the slope of fundamental and realised balance is significantly different for each richness level
# Fit the linear model with interaction
complete_aggr_2<- complete_aggr %>%
  # Remove the units from the 'nutrients' and 'temperature' columns
  mutate(
    nutrients = as.numeric(gsub(" g/L", "", nutrients)),  # Convert nutrients to numeric
    temperature = gsub(" ¬∞C", "", temperature)            # Remove the unit but keep as character
  ) %>%
  # Convert temperature ranges to numeric codes using case_when
  mutate(
    temperature = case_when(
      temperature == "18-21" ~ 1,
      temperature == "22-25" ~ 2,
      temperature == "25-28" ~ 3,
      TRUE ~ NA_real_         # Handle unexpected values with NA
    )
  )


# Fit the linear model with interaction
lm_full_int1<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+scale(nutrients)*scale(temperature)+richness)
lm_full_int2<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+ log10(balance_r)+scale(nutrients)*scale(temperature)+richness)

```

**Table 7**: Anova table of the model with only realised balance vs one with both realised and fundamental balance as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova5 <- anova(lm_full_int1, lm_full_int2)

anova_tidy5 <- broom::tidy(anova5)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy5 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```



A model with both fundamental and realised imbalance as predictors improved very little the variance explained by the model. The two models are not significantly different, suggesting that fundamental imbalance captures well the effect of imbalance on stability, and addiing the species contribution to total biomass (realised imbalnce) does not improved the model.

We now compare also the AIC of the two models
```{r include=TRUE, echo=TRUE}
AIC(lm_full_int1, lm_full_int2)
```

The AIC of the model with only fundamental imbalance is lower than the AIC of the model with both fundamental and realised imbalance, suggesting that the model with only fundamental imbalance is a better model. However, the difference is very small. 



```{r}

# Model with balance_f only
lm_balance_f <- lm(data = complete_aggr_2, 
                   log10(stability) ~ log10(balance_f) + scale(nutrients)*scale(temperature) + richness)

# Model with balance_r only
lm_balance_r <- lm(data = complete_aggr_2, 
                   log10(stability) ~ log10(balance_r) + scale(nutrients)*scale(temperature) + richness)


```

```{r}
# Compare AIC
AIC(lm_balance_f, lm_balance_r, lm_full_int1, lm_full_int2)

# Compare adjusted R¬≤
summary(lm_balance_f)$adj.r.squared

summary(lm_balance_r)$adj.r.squared

# ANOVA comparison (nested models)
anova(lm_balance_f, lm_full_int2)
anova(lm_balance_r, lm_full_int2)
```


```{r}
# Full model with both variables
lm_both <- lm(data = complete_aggr_2, 
              log10(stability) ~ log10(balance_f) + log10(balance_r) + scale(nutrients)*scale(temperature) + richness)

# Get R¬≤ values
r2_f <- summary(lm_balance_f)$r.squared
r2_r <- summary(lm_balance_r)$r.squared
r2_both <- summary(lm_both)$r.squared

# Shared variance
shared_variance <- r2_both - (r2_f + r2_r)
shared_variance

```

```{r}

# Scatter plot with regression lines
a1 <- ggplot(complete_aggr_2, aes(x = log10(balance_f), y = log10(stability))) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue", linetype = "dashed") +
  labs(title = "Balance_f vs Stability", x = "log10(balance_f)", y = "log10(stability)")

b1 <- ggplot(complete_aggr_2, aes(x = log10(balance_r), y = log10(stability))) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
  labs(title = "Balance_r vs Stability", x = "log10(balance_r)", y = "log10(stability)")

a1 + b1
```



```{r}

# Example: Using the R-squared values from the models
r2_f <- summary(lm_balance_f)$r.squared  # R¬≤ for balance_f model
r2_r <- summary(lm_balance_r)$r.squared  # R¬≤ for balance_r model
r2_both <- summary(lm_both)$r.squared    # R¬≤ for model with both variables

# Calculate shared variance
shared_variance <- r2_both - (r2_f + r2_r)
total_variance <- r2_both

# Percentage of shared variance
shared_percentage <- (shared_variance / total_variance) * 100
shared_percentage

```


# Linear models


## Model: Fundamental balance and Interaction between temperature and nutrients

We may expect and interactive effect of the environmental variables on stability. We thus build a linear model with interaction between temperature and nutrients.
However, there is high collinearity between temperature and nutrients, which may affect the model results. 

```{r model_check_int, fig.cap='model check 1.', fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_full_int<-lm(data=complete_aggr,log10(stability)~log10(balance_f)+(richness)+nutrients*temperature)

# check model assumptions
check_model(lm_full_int)

```
Assumptions not met.

So we transformed nutrients and temperature to numeric, and transformed temperature regimes in values = 1, 2, 3. Then, we centered the variables to avoid collinearity with the interaction term. 

```{r model_check_int2, fig.cap='model check 1.', fig.align="center", fig.height=9, fig.width=12, , include=TRUE, echo=TRUE}

# Fit the linear model with interaction
lm_full_int<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+scale(nutrients)*scale(temperature)+richness)

# check model assumptions
 check_model(lm_full_int)

```

Assumptions met.



**Table 8**: Linear model results for the effects of balance, richness, nutrients, and temperature on community stability. Estimates are presented with 95% confidence intervals and p-values. 
```{r}
# produce publication ready table using gtsummary::tbl_regression

# Generate the regression table with enhanced styling

gtsummary::tbl_regression(lm_full_int,
               add_estimate_to_reference_row = TRUE, # Adds reference values for categorical predictors
               add_pairwise_contrasts = TRUE,
               intercept = TRUE) %>% 
  # Customize table elements
  gtsummary::modify_header(label = "**Predictor**", estimate = "**Estimate**", conf.int = "**95% CI**", p.value = "**p-value**") %>%
  gtsummary::modify_footnote(everything() ~ NA) %>% # Remove default footnotes for clean look
  gtsummary::modify_spanning_header(c("estimate",  "p.value") ~ "**Linear Regression Results**") %>% # Title
  gtsummary::bold_labels() %>%
  gtsummary::as_gt() 



```
The relationship between community stability and the predictors, including imbalance, nutrient and temperature levels, and species richness, was analyzed using a linear model. Overall, the model explained 47.2% of the variation in community stability (adjusted R2 = 0.4581, F6,236 = 35.09, p<2.2√ó10‚àí16).
The results showed that the balance of species' responses to environmental conditions (log10(imbalancef) had a small but significant negative effect on stability.
Nutrient availability had a strong, positive effect on community stability (Œ≤=0.088¬±0.0088, p<2√ó10‚àí16p. 
In contrast, temperature significantly reduced stability (Œ≤=‚àí0.049¬±0.0100.010Œ≤=‚àí0.049¬±0.010, p=6.14√ó10‚àí6).
Species richness had no significant effect on stability.
The interaction between nutrients and temperature was not statistically significant (Œ≤=‚àí0.011¬±0.009, p=0.195), suggesting that their combined effects on stability were negligible under the tested conditions.

**Table 9**: ANOVA table of the model with interaction between temperature and nutrients as predictors of stability.

```{r}

# Get ANOVA table using car::Anova for Type III sum of squares
anova_table <- anova(lm_full_int)

# Convert to tidy format
anova_tidy <- broom::tidy(anova_table)

# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy %>%
  gt() %>%
  tab_header(title = "ANOVA Table for Linear Model") %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(16),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```


## Dependence of Imbalance on Temperature

Since imbalance depends on the slopes of species' responses, and the slopes of species responses between two environmental conditions depend on the shape of species responses and the position of the optimum of the species response curve, we may expect that imbalance depends on temperature. For example, when the environment (i.e. temperature) fluctuates at higher mean temperatures, the species responses may be more similar (i.e. all species have the same sign of response), leading to less symmetrical response distributions, and thus higher imbalance.

We look now at how imbalance changes with temperature, in all possible combinations of species responses for each richness level and each environmental condition. We calculate the sum of slopes of all possible combinations of species responses, and then calculate the imbalance for each combination. We then plot the relationship between imbalance and temperature for each combination of species responses.


```{r}
# Function to calculate combinations and their sum of slopes
calculate_compositions <- function(data) {
  # Generate combinations for n = 2, n = 3, n = 4
  combinations <- lapply(2:4, function(n) combn(data$predict_spec, n, simplify = FALSE))
  combinations <- unlist(combinations, recursive = FALSE)
  # Create a dataframe with combinations and their summed slopes
  result <- data.frame(
    composition = sapply(combinations, paste, collapse = ""),
    sum_slopes = sapply(combinations, function(comb) {
      sum(data$slope[data$predict_spec %in% comb])
    }),
    magnitude=sapply(combinations, function(comb) {
      sum(abs(data$slope[data$predict_spec %in% comb]))
    })
  )
  return(result)
}
 
 
# Apply the function for each group of `nutrients` and `temperature`
all_combi_df <- df_slopes %>%
  group_by(nutrients, temperature) %>%
  group_split() %>%
  lapply(function(group_data) {
    compositions <- calculate_compositions(group_data)
    # Add nutrients and temperature columns to each result
    compositions$nutrients <- unique(group_data$nutrients)
    compositions$temperature <- unique(group_data$temperature)
    return(compositions)
  }) %>%
  bind_rows()
 
all_combi_df<-all_combi_df%>%mutate(balance=abs(sum_slopes),
                              richness=as.factor(nchar(composition)))
 
all_combi_df<-all_combi_df%>%mutate(is_selected=all_combi_df$balance%in%complete_aggr$balance_f)
 
test_representative<-t.test(log10(dplyr::filter(all_combi_df,is_selected==F)$balance),log10(dplyr::filter(all_combi_df,is_selected==T)$balance),var.equal = F)
 
 
lm_representative<-lm(data=all_combi_df,log10(balance)~temperature*is_selected)
#check_model(lm_representative)
```

```{r effect_T, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=20}
plot_all_combi<-ggplot(data=all_combi_df)+theme_bw(base_size = 25)+
  geom_quasirandom(data= all_combi_df,aes(y=log10(balance), x=temperature, group=temperature, colour=as.factor(temperature)),
                                  dodge.width=2, size= 6) +
 
  xlab("Temperature regime")+
  ylab("log10(balance)")+
  labs(color="Temperature regime", tag = "(a)")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  facet_wrap(~is_selected,labeller = as_labeller(c("FALSE"="Not Selected","TRUE"="Selected")))+
  theme(legend.position = "none", strip.text = element_text(size = 25),
         strip.background = element_rect(fill = "grey80", color = NA))
 
 
plot_all_combi
```

**Figure 7**: Relationship between imbalance and temperature for all possible combinations of species responses. The points represent the imbalance of each combination of species responses The points are colored by temperature regime, and the facets represent whether the combination of species responses was selected for the experiment.


We can see that imbalance increases with temperature, and that the relationship is the same in selected vs non selected community compositions. This suggests that imbalance is intrinsically dependent on temperatures, and that the species responses are more similar when the environment fluctuates at higher temperatures.
Inevitably, this will affect the stability of the community, as we have seen in the previous analysis. Yet, it also mean that the effect of imbalance on stability is not independent of temperature.

We now build a linear model without temperature as a predictor, as it may share explained variance with imbalance .
```{r}
lm_full_no_T<-lm(data=complete_aggr,log10(stability)~log10(balance_f)+(nutrients)+richness)


#check_model(lm_full_no_T)
```

**Table 10**:Linear model results for the effects of balance, richness, nutrients, but *not* temperature on community stability. Estimates are presented with 95% confidence intervals and p-values. 
```{r}
gtsummary::tbl_regression(lm_full_no_T,
               add_estimate_to_reference_row = TRUE, # Adds reference values for categorical predictors
               add_pairwise_contrasts = TRUE,
               intercept = TRUE) %>% 
  # Customize table elements
  gtsummary::modify_header(label = "**Predictor**", estimate = "**Estimate**", conf.int = "**95% CI**", p.value = "**p-value**") %>%
  gtsummary::modify_footnote(everything() ~ NA) %>% # Remove default footnotes for clean look
  gtsummary::modify_spanning_header(c("estimate",  "p.value") ~ "**Linear Regression Results**") %>% # Title
  gtsummary::bold_labels() %>%
  gtsummary::as_gt() 
```








**Table 11**: Comparison of model performance of the full model and a model without temperature as predictors of stability.
```{r}
performance(lm_full_int) %>% 
  bind_rows(., performance(lm_full_no_T), .id = "model") %>% 
  kable() %>% 
  kable_styling(full_width = F)
```


Removing temperature as a predictor did not affect the model performance, suggesting that temperature and imbalance share explained variance. Yet, without temperature, the estimate of balance on stability increased almost 3-fold, suggesting that temperature may have masked the effect of imbalance on stability.



## Control effect of environment for balance

```{r}
lm_temp_resid<-lm(data=complete_aggr_2, temperature ~ log10(balance_f))

lm_nut_resid<-lm(data=complete_aggr_2, nutrients ~ log10(balance_f))
 
resid_temp<-lm_temp_resid$residuals

resid_nut<-lm_nut_resid$residuals
 
complete_aggr_2<-complete_aggr_2%>%mutate(resid_temp=resid_temp,resid_nut=resid_nut)
 
# fit linear model with residuals

lm_resid_int<-lm(data=complete_aggr_2,log10(stability)~richness+log10(balance_f) +resid_temp*resid_nut)
summary(lm_resid_int)
```

```{r}
# produce publication ready table using gtsummary::tbl_regression
 
# Generate the regression table with enhanced styling
 
model_summary<-summary(lm_resid_int)

t_values <- model_summary$coefficients[, "t value"]

std_error <- model_summary$coefficients[, "Std. Error"]
 
# produce publication ready table using gtsummary::tbl_regression
 
 
# Generate the regression table with enhanced styling
 
main_tbl_red<-gtsummary::tbl_regression(lm_resid_int,intercept=T,

                          label=list("(Intercept)" = "Intercept",

                                     log_balance="log10(balance)",

                                     nut_scaled="nutrients (scaled)",

                                     temp_scaled="temperature (scaled)",

                                    "nut_scaled*temp_scaled"= "nutrients x temperature (scaled)"),

               add_estimate_to_reference_row = TRUE, # Adds reference values for categorical predictors

               add_pairwise_contrasts = TRUE,

               add_significance_stars=T) %>% 

  gtsummary::modify_table_body(

    ~ .x %>%

      dplyr::mutate(

        t_value = ifelse(!is.na(estimate), round(t_values, 2), NA),

        std_error= ifelse(!is.na(estimate), round(std_error, 2), NA)

      )%>%dplyr::relocate(p.value, .after = t_value)%>%dplyr::relocate(std_error, .after = estimate)

  ) %>%

  # Customize table elements

  gtsummary::modify_header(label = "**Predictor**", estimate = "**Estimate**", conf.int = "**95% CI**",df="**df**",t_value="**t-value**", p.value = "**p-value**",std_error="**SE**") %>%

  gtsummary::modify_footnote(everything() ~ NA) %>% # Remove default footnotes for clean look

  gtsummary::bold_labels() %>%

  gtsummary::as_gt() %>%

  tab_header(title=("Linear Regression Results"))
 
main_tbl_red
```

```{r}


# Fit the mixed-effects model without random effects
model_no_random <- lmer(log10(stability) ~ log10(balance_f) + resid_temp*resid_nut + richness + 
                        (1 | composition), data = complete_aggr_2, REML = FALSE)
summary(model_no_random)
qqnorm(residuals(model_no_random))
check_model(model_no_random)
# Fit the mixed-effects model with random effects
model_with_random <- lmer(log10(stability) ~ log10(balance_f) + resid_temp*resid_nut+ richness + 
                          (1 + log10(balance_f) | composition), data = complete_aggr_2, REML = FALSE)
summary(model_with_random)
qqnorm(residuals(model_with_random))

# Compare the models
anova(model_no_random, model_with_random)
car::Anova(model_no_random, type = "III")
r2(model_no_random)



lm_full_int1<-lmer(log10(stability) ~ log10(balance_f) + resid_temp*resid_nut + richness + 
                        (1 | composition), data = complete_aggr_2, REML = FALSE)
lm_full_int2<-lmer(log10(stability) ~ log10(balance_f) + log10(balance_r) + resid_temp*resid_nut + richness + 
                        (1 | composition), data = complete_aggr_2, REML = FALSE)
anova(lm_full_int1, lm_full_int2)
```




```{r}
# Create a gtsummary table

tbl_summary <- gtsummary::tbl_regression(model_no_random,intercept=T,

                          label=list("(Intercept)" = "Intercept",

                                     log_balance="log10(balance)",

                                     nut_scaled="nutrients (scaled)",

                                     temp_scaled="temperature (scaled)",

                                    "nut_scaled*temp_scaled"= "nutrients x temperature (scaled)"),

               add_estimate_to_reference_row = TRUE, # Adds reference values for categorical predictors

               add_pairwise_contrasts = TRUE,

               add_significance_stars=T) %>% 

  gtsummary::modify_table_body(

    ~ .x %>%

      dplyr::mutate(

        t_value = ifelse(!is.na(estimate), round(t_values, 2), NA),

        std_error= ifelse(!is.na(estimate), round(std_error, 2), NA)

      )%>%dplyr::relocate(p.value, .after = t_value)%>%dplyr::relocate(std_error, .after = estimate)

  ) %>%

  # Customize table elements

  gtsummary::modify_header(label = "**Predictor**", estimate = "**Estimate**", conf.int = "**95% CI**",df="**df**",t_value="**t-value**", p.value = "**p-value**",std_error="**SE**") %>%

  gtsummary::modify_footnote(everything() ~ NA) %>% # Remove default footnotes for clean look

  gtsummary::bold_labels() %>%

  gtsummary::as_gt() %>%

  tab_header(title=("Linear Regression Results"))
 

# Print the table
tbl_summary



```




```{r Rsquared,  fig.align="center", fig.height=6, fig.width=12}
lm_balance_env<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+scale(nutrients)*scale(temperature))
lm_balance<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f))
lm_env<-lm(data=complete_aggr_2,log10(stability)~scale(nutrients)*scale(temperature))
 
 
sum_lm_balance<-summary(lm_balance)
sum_lm_env<-summary(lm_env)
sum_lm_balance_env<-summary(lm_balance_env)
 
  
R2_env_bal<-data.frame(R2=c(sum_lm_balance$r.squared,sum_lm_env$r.squared,sum_lm_balance_env$r.squared,
                            sum_lm_balance_env$r.squared-sum_lm_env$r.squared,
                            sum_lm_balance_env$r.squared-sum_lm_balance$r.squared,
                            0),
                       model=factor(c("log10(balance)","nut * temp","log10(balance) + nut * temp","log10(balance)","nut * temp","log10(balance) + nut * temp")),
                       type=c("total","total","total","unique","unique","unique"))
 
 
plot_R2_bal_env<-ggplot(data=R2_env_bal%>%dplyr::filter(type=="total"),aes(y=R2,x=factor(model,levels=c("log10(balance)","nut * temp","log10(balance) + nut * temp")),fill=type))+
  geom_col(width=0.7)+
  geom_col(data=R2_env_bal%>%dplyr::filter(type=="unique"),width=0.7)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
         axis.text = element_text(size = 15),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 18),plot.tag = element_text(size = 18),
     legend.text = element_text(size = 15), # Adjust legend text size
    legend.title = element_blank() ) +
   xlab("Model terms") +
  ylab(expression(R^2))+
  scale_fill_manual(values = c("total" = "grey80", "unique" = "grey20"))+labs(tag="(a)")
plot_R2_bal_env
```




# Asynchrony
Response diversity (one of the stabilisng effects captured by imbalance) has been suggested as a mechanism that promotes temporal stability of community biomass by promoting species asynchrony.

We thus calculated the asynchrony index suggested by [Gross et al. 2014](https://www.journals.uchicago.edu/doi/epdf/10.1086/673915) to calculate the effect of asynchrony on temporal stability and to see how response diversity relate to asynchrony.
The index ranges between -1 and 1, with -1 indicating perfect asynchrony and 1 being perfectly synchronous, and 0 indicating random variation.


```{r echo=F, warning=FALSE, results='hide'}

#filter out completely extinct microcosms


async_df<-complete_ts%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))


async_Gross <- async_df %>% group_by(composition,sample_ID) %>%  
  do(synchrony_Gross = synchrony(., "day", "predict_spec", 
                              "biomass", metric = "Gross"))
async_Gross<-dplyr::mutate(async_Gross,synchrony_Gross=synchrony_Gross%>%unlist())

async_Loroeau <- async_df %>% group_by(composition,sample_ID) %>%  
  do(synchrony_L = synchrony(., "day", "predict_spec", 
                              "biomass", metric = "Loreau"))
async_Loroeau<-dplyr::mutate(async_Loroeau,synchrony_Loreau=synchrony_L%>%unlist())

async_aggr<-full_join(async_Gross,complete_aggr,join_by(sample_ID,composition))

async_aggr<-full_join(async_aggr,async_Loroeau,join_by(sample_ID,composition))

async_aggr_f<-async_aggr%>%dplyr::filter(nutrients!="0.01 g/L")
async_aggr<-async_aggr%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))

# calculate spearman correlation coefficient and p value between asynchrony and stability


# nice table with the correlation coefficient and p value of the correlation between asynchrony and stability
cor.test(async_aggr$synchrony_Gross,async_aggr$balance_f) %>% 
  broom::tidy() %>% 
  dplyr::select(estimate, p.value) %>% 
  kable() %>% 
  kable_styling(full_width = F)


```


### Plot stability vs. Asynchrony Gross
```{r async_plots, fig.align="center", fig.height=6, fig.width=12}
plot_asynch_CV_G<-ggplot(data=async_aggr,aes(x=-synchrony_Gross,y=log10(1/CV),color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) +
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
   ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("Asynchrony")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)



plot_asynch_CV_G

```


**Figure 8**: Relationship between temporal stability and asynchrony (Gross) divided by nutrient level.


The Pearson's correlation between asynchrony and stability is significant (estimate = -0.23, p < 0.001).
```{r include=TRUE, echo=TRUE}
cor.test((-1*async_aggr$synchrony_Gross),async_aggr$stability)
```


### Plot Asynchrony Gross vs fundamental imbalance

```{r async,  fig.align="center", fig.height=6, fig.width=12}

plot_asynch_B_G<-ggplot(data=async_aggr,aes(x=log10(balance_f),y=-synchrony_Gross,color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
   xlab(expression(log10(Imbalance)["fund"] )) +
  ylab("Asynchrony")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)



plot_asynch_B_G

```
**Figure 9**: Relationship between asynchrony (Gross) and fundamental imbalance divided by nutrient level.

The Pearson's correlation between asynchrony and imbalance is significant (estimate = 18, p = 0.003).
```{r include=TRUE, echo=TRUE}
cor.test((-1*async_aggr$synchrony_Gross),(async_aggr$balance_f))
```





```{r fig.align="center", fig.height=12, fig.width=16}

plot_asynch_CV_G <- plot_asynch_CV_G +
  labs(tag = "(a)") +
  theme(plot.tag = element_text(size = 20))+ theme(legend.position = "none")

plot_asynch_B_G <- plot_asynch_B_G +
  labs(tag = "(b)") +
  theme(plot.tag = element_text(size = 20)) + theme(legend.position = "none")

plot_pop_aggr_balance <- plot_pop_aggr_balance +
  labs(tag = "(c)") +
  theme(plot.tag = element_text(size = 20))

plot_pop_balance <- plot_pop_balance +
  labs(tag = "(d)") +
  theme(plot.tag = element_text(size = 20))+ theme(legend.position = "none")


 

# Combine plots and share the legend
fig3 <- (plot_asynch_CV_G + plot_asynch_B_G) / 
        (plot_pop_aggr_balance + plot_pop_balance) + 
        plot_layout(guides = "collect")

fig3




# ggsave("figures_ms/fig.3.png", plot = fig3, width = 18, height = 12, dpi = 600)
```



## Eveness
Evenness in species biomass has been identified as an important factor potentially influencing ecosystem stability [Thibaut & Connolly 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12019). In the context of our experiment, evenness in species biomass could help explaining why there is little difference between fundamental and realized imbalance. If evenness is high, then all species contribute similarly to total biomass. In this case, weighting for species-biomass contribution to total biomass (realized), should not fundamentally change the result, compared to an un-weighted (fundamental) measurement. 
```{r eveness,  fig.align="center", fig.height=6, fig.width=8}

even_aggr<-complete_ts%>%group_by(sample_ID,predict_spec,richness)%>%summarize(mean_biom_contribution=mean(biom_contribution,na.rm=T))%>%ungroup()
 
 
# exclude microcosms where all but one species 
even_aggr<-even_aggr%>%dplyr::filter(!(mean_biom_contribution%in%c(0,1)))
 
even_aggr<-even_aggr%>%group_by(sample_ID,richness)%>%reframe(H= -sum(mean_biom_contribution*log(mean_biom_contribution)))
even_aggr<-even_aggr%>%mutate(evenness=H/log(as.numeric(richness)))
 
even_aggr<-full_join(even_aggr,async_aggr,by=c("sample_ID"))
 
mean_evenness <- mean(even_aggr$evenness, na.rm = TRUE)

# Create the histogram with the mean indicated
dist_even <- ggplot(data = even_aggr, aes(x = evenness)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black", alpha = 0.7) + # Adjust binwidth for better visualization
  geom_vline(aes(xintercept = mean_evenness), color = "red", linetype = "dashed", size = 1.2) + # Add the mean line
  theme_classic() +
  labs(
    x = "Evenness",
    y = "Frequency",
    title = "Distribution of Evenness with Mean"
  ) +
  annotate("text", x = mean_evenness, y = 5, label = paste0("Mean = ", round(mean_evenness, 2)), 
           color = "red", hjust = -0.1, size = 5)

# Print the plot
dist_even
```
**Figure 10**: Distribution of species evenness across experimental communities. The histogram represents the frequency of observed evenness values, while the red dashed line indicates the mean evenness (0.7). This highlights the central tendency of evenness across the dataset and its variation among communities.

Evenness was indeed generally high in our experimental communities, suggesting another potential factor reducing the potential difference between fundamental and realized balance. 

# Population stability

The relationship between community stability and the stability of the individual populations that make up the community is a key question in ecology. Importantly, ecosystem stability can result from low population stability, if populations fluctuate asynchronously, or from high population stability, if populations do not fluctuate much.
Synthesis of the literature suggests diversity can have a positive or negantive effect on population stability [Campbell et al 2010](https://nsojournals.onlinelibrary.wiley.com/doi/full/10.1111/j.1600-0706.2010.18768.x) and (Xu et al 2021)[https://onlinelibrary.wiley.com/doi/full/10.1111/ele.13777].

Theoretical work has suggested that community stability is a product of two quantities: the (a) synchrony of population fluctuations, and an average species-level population stability that is weighted by relative abundance [Thibaut & Connolly 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12019). 

Critically, a imbalance value close to zero can result from high response diversity, but also from high population stability (population biomass does not change largely over time).
We want to look now at whether our new metric of imbalance can capture these two stabilising mechanisms.

Thus, we calculate species-level population stability weighted by relative abundance and look at how it relates to ecosystem stability. 

```{r echo=FALSE, warning=FALSE, results='hide'}


pop_aggr<-complete_ts%>%group_by(sample_ID,predict_spec)%>%summarize(pop_CV=sd(biomass)/mean(biomass),mean_biom_contribution=mean(biom_contribution,na.rm=T), pop_V= sd(biomass))

# Lehman & Tilman (2000), THIBAUT & Connolli (2013), Gross et al. (2014)

pop_aggr<-pop_aggr%>%group_by(sample_ID)%>%summarize(pop_V=sum(pop_V),
                                                     w_pop_CV=sum(pop_CV*mean_biom_contribution, na.rm=T))

pop_aggr<-pop_aggr%>%group_by(sample_ID)%>%full_join(async_aggr,pop_aggr,by="sample_ID")


plot_pop_aggr_balance <- ggplot(data = pop_aggr, aes(y = log10(stability), x = log10(1 / w_pop_CV), color = nutrients)) +
  geom_point(size = 3.5, alpha = 0.65) +
  geom_smooth(method = "lm", linewidth = 2, show.legend = F) +
  theme_classic(base_size = 25) +
  scale_color_viridis_d(option = "plasma", begin= 0.15, end= 0.85 ) +  # Use plasma palette
  labs(x = "log10(population stability)", y = "Temporal stability\nlog(mean/s.d.)")


plot_pop_aggr_balance

#ggsave("figures_ms/fig.pop_stab.png", plot = plot_pop_aggr_balance, width = 9, height = 6, dpi = 600)

# cor.test(pop_aggr$w_pop_CV,pop_aggr$stability)



```

**Figure 11**: Relationship between log10 of population stability and log 10 of ecosystem stability.  


```{r pop_balance,  fig.align="center", fig.height=6, fig.width=12}
plot_pop_balance<-ggplot(data=pop_aggr,aes(x=log10(balance_f), y = log10(1 / w_pop_CV),color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
   xlab(expression(log10(Imbalance)["fund"] )) +
  ylab("Population stability")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)


plot_pop_balance
```

# SEM 


Finally, we use a structural equation model (SEM) to explore how stability is influenced by asynchrony, population stability, imbalance and, nutrient levels. 
In order to develop a hypothesis regarding the influence of stability, we have drawn on existing literature. This has enabled us to posit that stability is influenced by two key factors: asynchrony and population stability. In turn, these are influenced by balance and, in our particular case, by nutrient levels.


```{r}

sem_aggr3 <- pop_aggr %>%
  ungroup() %>%  # Ensure there is no grouping
  mutate(
    log_balance_f = log10(balance_f),
    stability = log10(1 / CV),
    richness = as.numeric(richness),
    temperature=temperature,
    asynchrony_Gross= (-synchrony_Gross),
    pop_stability= log10(1/w_pop_CV),
    pop_var = log10(pop_V)
    #Keep it as an ordered factor
  )

model1C <- '
  stability ~ asynchrony_Gross
  +pop_stability 
 
  asynchrony_Gross ~ log_balance_f + nutrients 
  pop_stability~log_balance_f + nutrients  + temperature
  
  
  log_balance_f ~ nutrients + temperature
'




# Fit the model

fit1C <- sem(model1C,estimator="MLM",meanstructure = TRUE,data = sem_aggr3%>%dplyr::filter(!is.na(asynchrony_Gross)))
#modificationindices(fit1C)

# Summarize the results
summary(fit1C, standardized = TRUE,rsquare=T, fit.measures = TRUE)

```

```{r SEM, fig.cap = 'SEM.', fig.align="center", fig.height=6, fig.width=8}
knitr::include_graphics(("figures_ms/SEM_3.png"))

```
**Figure 12**: Structural equation model (SEM) showing the relationships between stability, asynchrony, population stability, imbalance, and nutrient levels. The model includes standardized regression coefficients and fit indices.

**Model Fit Indices**
The model fit indices suggest that the model fits the data well.

*Chi-Square Test (User Model)*: The chi-square test statistic for the user model is œá 2 =1.626 (scaled = 1.465) with 3 degrees of freedom and a p-value of 0.653 (scaled = 0.690). This indicates a good fit, as the test is non-significant, suggesting no significant difference between the observed and model-implied covariance matrices.

*Comparative Fit Index (CFI)* and *Tucker-Lewis Index (TLI)*: Both CFI and TLI values are 1.000, indicating an excellent model fit. Values close to or above 0.95 are generally considered good.

*Root Mean Square Error of Approximation (RMSEA)*: The RMSEA is 0.000, with a 90% confidence interval ranging from 0 to 0.090 (scaled = 0.080). This indicates a very good fit, as RMSEA values below 0.05 are ideal, and values below 0.08 are acceptable. The p-values for the RMSEA hypothesis tests suggest strong support for a close fit (RMSEA <= 0.05) and little evidence for a poor fit (RMSEA >= 0.08).

*Standardized Root Mean Square Residual (SRMR)*: The SRMR value is 0.017, which is also within the acceptable range (values below 0.08 are generally considered good).
Overall, the fit indices suggest that the model is an excellent fit for the data.

**Regression Paths and Interpretation**

**Stability Regressions**

*Stability ~ Asynchrony_Gross (asynchrny_Grss)*: The standardized estimate for the effect of asynchrony on stability is 0.340 (p < 0.001), indicating a significant positive association. Higher asynchrony in species dynamics is associated with increased community stability.

*Stability ~ Population Stability (pop_stability)*: The standardized estimate is 0.977 (p < 0.001), showing a strong positive relationship. This suggests that community stability is highly dependent on the stability of individual populations within the community.

**Asynchrony_Gross Regressions**

*Asynchrony_Gross ~ Log10(Balance):* The standardized estimate is -0.176 (p = 0.013), indicating a significant negative effect. Higher imbalance leads to lower asynchrony, suggesting that as imbalance increases, species within the community fluctuate more synchronously.

*Asynchrony_Gross ~ Nutrients:* The standardized estimate is -0.469 (p < 0.001), showing a strong negative relationship. Higher nutrient levels appear to reduce asynchrony, possibly by causing similar responses across species.

**Population Stability Regressions**

*Population Stability ~ Log10(Balance)*: The standardized estimate is -0.296 (p < 0.001), indicating that higher imbalance is associated with lower population stability.

*Population Stability ~ Nutrients*: The standardized estimate is 0.635 (p < 0.001), showing that higher nutrient levels are associated with increased population stability, likely because nutrients enhance conditions that support stable population dynamics.

**Variances and R-Squared Values**
*R-Squared for Stability*: The model explains 90.4% of the variance in community stability, indicating strong predictive power.

*R-Squared for Asynchrony_Gross*: The model explains 21.9% of the variance in asynchrony, which is moderate.

*R-Squared for Population Stability*: The model explains 56.2% of the variance in population stability, showing that nutrients and balance are important but not the only factors influencing it.

*Summary Interpretation*
Model Fit: The model has an excellent fit, as indicated by the fit indices.
Stability: Community stability is strongly influenced by both population stability and asynchrony among species, with population stability being the stronger predictor.
Asynchrony and Imbalance: Asynchrony decreases with increasing imbalance and nutrients, suggesting that these factors promote more synchronized fluctuations among species.
Population Stability and Nutrients: Higher nutrient levels are associated with increased population stability, suggesting that nutrient availability supports stable population dynamics. Conversely, higher imbalance is associated with decreased population stability.

